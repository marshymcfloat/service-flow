// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider = "prisma-client"
  output   = "./generated/prisma"
}

datasource db {
  provider = "postgresql"
}

model Business {
  id   String @id @default(cuid())
  name String
  slug String @unique
  initials String @db.Char(2)
  description String?

  imageUrl String?

  latitude Float?
  longitude Float?

  services Service[]
  employees Employee[]
  owners    Owner[]
  customers Customer[]
  bookings Booking[]
  sale_events SaleEvent[]
  vouchers Voucher[]
  special_dates SpecialDate[]
  packages ServicePackage[]
  leave_requests LeaveRequest[]
  business_hours BusinessHours[]
  service_flows ServiceFlow[]
  commission_calculation_basis CommissionCalculationBasis @default(ORIGINAL_PRICE)

  created_at DateTime @default(now())
  updated_at DateTime @updatedAt
}

model LeaveRequest {
  id Int @id @default(autoincrement())
  
  employee_id Int
  employee Employee @relation(fields: [employee_id], references: [id], onDelete: Cascade)

  business_id String
  business Business @relation(fields: [business_id], references: [id], onDelete: Cascade)

  start_date DateTime
  end_date DateTime
  reason String
  status LeaveRequestStatus @default(PENDING)
  admin_comment String?

  created_at DateTime @default(now())
  updated_at DateTime @updatedAt
}

enum Role {
  OWNER
  EMPLOYEE
}

enum VoucherType {
  PERCENTAGE
  FLAT
}

enum DiscountType {
  PERCENTAGE
  FLAT
}
enum BookingStatus {
  HOLD       // Slot reserved during payment
  ACCEPTED
  COMPLETED
  CANCELLED
}

enum PayslipStatus {
  PENDING
  PAID
  REJECTED
}

enum AttendanceStatus {
  PRESENT
  ABSENT
  LATE
  OFF
  LEAVE
}

enum PaymentMethod {
  CASH
  QRPH
}

enum AvailedServiceStatus {
  PENDING     // No employee claimed yet
  CLAIMED     // Employee claimed, not yet served
  SERVING     // Currently being served
  COMPLETED   // Service finished
  CANCELLED   // Service cancelled
}

enum LeaveRequestStatus {
  PENDING
  APPROVED
  REJECTED
}

model BusinessHours {
  id          Int     @id @default(autoincrement())
  day_of_week Int     
  open_time   String  // "09:00" (24hr format)
  close_time  String  // "18:00"
  is_closed   Boolean @default(false)
  
  category    String  @default("GENERAL") // "GENERAL", "Spa", "Nails", etc.

  business_id String
  business    Business @relation(fields: [business_id], references: [id], onDelete: Cascade)

  @@unique([business_id, day_of_week, category])
}

model SaleEvent {
  id Int @id @default(autoincrement())

  title String 
  description String?

  start_date DateTime
  end_date DateTime

  discount_type DiscountType @default(PERCENTAGE)
  discount_value Float @default(0)

  applicable_services Service[]
  applicable_packages ServicePackage[]

  business_id String
  business    Business @relation(fields: [business_id], references: [id], onDelete: Cascade)

  created_at DateTime @default(now())
  updated_at DateTime @updatedAt
}

model User {
  id    String @id @default(cuid())
  email String @unique
  hashed_password String
  name  String

  role      Role       @default(EMPLOYEE)
  employee  Employee?
  owner     Owner?

  created_at DateTime @default(now())
  updated_at DateTime @updatedAt
}

model Employee {
  id      Int    @id @default(autoincrement())
  user_id String @unique
  user    User   @relation(fields: [user_id], references: [id], onDelete: Cascade)
  salary Float
  commission_percentage Float @default(0)
  daily_rate Float @default(0)
  specialties String[] @default([]) // Array of service categories this employee can perform
  attendance EmployeeAttendance[]



  served_services AvailedService[]
  payslips Payslip[]
  leave_requests LeaveRequest[]


  business_id String
  business    Business @relation(fields: [business_id], references: [id], onDelete: Cascade)

  @@unique([business_id, user_id])
}

model EmployeeAttendance{
  id Int @id @default(autoincrement())
  employee_id Int
  employee Employee @relation(fields: [employee_id], references: [id], onDelete: Cascade)

  date DateTime
  status AttendanceStatus @default(PRESENT)
  
  time_in DateTime?
  time_out DateTime?
  location_verified Boolean @default(false)
  latitude Float?
  longitude Float?

  created_at DateTime @default(now())
  updated_at DateTime @updatedAt
}
model Payslip {
  id Int @id @default(autoincrement())

  employee_id Int
  employee    Employee @relation(fields: [employee_id], references: [id], onDelete: Cascade)

  starting_date DateTime
  ending_date DateTime
  comment String?
  deduction Float @default(0)
  status PayslipStatus @default(PENDING)

  total_salary Float
}

model SpecialDate {
  id Int @id @default(autoincrement())
  date DateTime
  
  salary_multiplier Float @default(1)
  commission_multiplier Float @default(1)

  business_id String
  business Business @relation(fields: [business_id], references: [id], onDelete: Cascade)

  created_at DateTime @default(now())
  updated_at DateTime @updatedAt
}

model Owner {
  id      Int    @id @default(autoincrement())
  user_id String @unique
  user    User   @relation(fields: [user_id], references: [id], onDelete: Cascade)

  business_id String
  business    Business @relation(fields: [business_id], references: [id], onDelete: Cascade)

  @@unique([business_id, user_id])
}

model Service {
  id Int @id @default(autoincrement())
  name String
  description String?
  price Float
  duration Int?
  category String

  business_id String
  business    Business @relation(fields: [business_id], references: [id], onDelete: Cascade)

  availed_services AvailedService[]
  sale_events SaleEvent[]
  package_items PackageItem[]

  flow_triggers ServiceFlow[] @relation("FlowTrigger")
  flow_suggestions ServiceFlow[] @relation("FlowSuggestion")

  created_at DateTime @default(now())
  updated_at DateTime @updatedAt
}

model ServicePackage {
  id Int @id @default(autoincrement())
  name String
  description String?
  price Float
  duration Int?
  category String

  business_id String
  business    Business @relation(fields: [business_id], references: [id], onDelete: Cascade)

  items PackageItem[]
  availed_services AvailedService[]
  sale_events SaleEvent[]

  created_at DateTime @default(now())
  updated_at DateTime @updatedAt
}

model PackageItem {
  id Int @id @default(autoincrement())

  custom_price Float

  package_id Int
  package    ServicePackage @relation(fields: [package_id], references: [id], onDelete: Cascade)

  service_id Int
  service    Service @relation(fields: [service_id], references: [id], onDelete: Cascade)

  @@unique([package_id, service_id])
}


model Customer {
  id String @id @default(cuid())
  name String
  email String?
  phone String?
  
  business_id String
  business    Business @relation(fields: [business_id], references: [id], onDelete: Cascade)

  bookings Booking[]

  created_at DateTime @default(now())
  updated_at DateTime @updatedAt
}




model Booking {

  id Int @id @default(autoincrement())

  status BookingStatus @default(ACCEPTED)
  customer Customer @relation(fields: [customer_id], references: [id], onDelete: Cascade)
  customer_id String

  business Business @relation(fields: [business_id], references: [id], onDelete: Cascade)
  business_id String

  vouchers Voucher[]

  payment_method PaymentMethod @default(CASH)
  availed_services AvailedService[]
  grand_total Float
  total_discount Float
  downpayment Float?
  downpayment_status BookingStatus? @default(ACCEPTED)
  downpayment_date DateTime?

  // Scheduling fields
  scheduled_at  DateTime?  // When the booking is scheduled to start
  estimated_end DateTime?  // Calculated from service durations
  reminder_sent Boolean @default(false)
  hold_expires_at DateTime? // When HOLD status expires (for online payments)
  
  // Computed columns for double-booking prevention (maintained by DB triggers)
  /// @ignore - Managed by database triggers, do not write directly
  booking_range String? @ignore
  /// @ignore - Managed by database triggers, do not write directly  
  is_active_booking Boolean? @ignore

  created_at DateTime @default(now())
  updated_at DateTime @updatedAt
}

model Voucher{
  id Int @id @default(autoincrement())
  code String @unique
  value Float
  type VoucherType @default(PERCENTAGE)
  minimum_amount Float @default(0)

  expires_at DateTime
  is_active Boolean @default(true)

  used_by_id Int?
  used_by Booking? @relation(fields: [used_by_id], references: [id], onDelete: Cascade)
 
  business_id String
  business Business @relation(fields: [business_id], references: [id], onDelete: Cascade)

  created_at DateTime @default(now())
  updated_at DateTime @updatedAt


}

model AvailedService {
  id Int @id @default(autoincrement())
  
  // Pricing
  price Float                      // Original service price at time of booking
  discount Float @default(0)       // Discount amount applied
  discount_reason String?          // "SALE_EVENT", "MANUAL", "FAMILY_DISCOUNT", etc.
  final_price Float                // price - discount = what customer pays
  commission_base Float             // What the employee's commission is calculated on

  // Claiming status
  status AvailedServiceStatus @default(PENDING)
  claimed_at DateTime?              // When employee claimed this service
  served_at DateTime?               // When service actually started
  completed_at DateTime?            // When service finished
  cancelled_at DateTime?

  booking_id Int
  booking    Booking  @relation(fields: [booking_id], references: [id], onDelete: Cascade)

  service_id Int
  service    Service  @relation(fields: [service_id], references: [id], onDelete: Cascade)

  // Optional: track if this came from a package
  package_id Int?
  package    ServicePackage? @relation(fields: [package_id], references: [id], onDelete: SetNull)

  served_by_id Int?
  served_by Employee? @relation(fields: [served_by_id], references: [id], onDelete: SetNull)

  // Scheduling fields
  scheduled_at  DateTime?  // When this specific service starts
  estimated_end DateTime?  // scheduled_at + duration

  created_at DateTime @default(now())
  updated_at DateTime @updatedAt
}



model ServiceFlow {
  id String @id @default(cuid())

  // The service that triggers this flow
  trigger_service_id Int
  trigger_service    Service @relation("FlowTrigger", fields: [trigger_service_id], references: [id], onDelete: Cascade)

  // The service being suggested/required next
  suggested_service_id Int
  suggested_service    Service @relation("FlowSuggestion", fields: [suggested_service_id], references: [id], onDelete: Cascade)

  // Timing
  delay_duration Int            // e.g., 2
  delay_unit     FlowDelayUnit  // e.g., DAYS

  // Logic
  type FlowType @default(SUGGESTED) 

  business_id String
  business    Business @relation(fields: [business_id], references: [id], onDelete: Cascade)

  created_at DateTime @default(now())
  updated_at DateTime @updatedAt
}

enum FlowDelayUnit {
  DAYS
  WEEKS
  MONTHS
}

enum FlowType {
  REQUIRED   // "Part of a process" - User expects this to happen
  SUGGESTED  // "Recommendation" - User might want this
}

enum CommissionCalculationBasis {
  ORIGINAL_PRICE
  DISCOUNTED_PRICE
}

// Transactional Outbox: ensures side-effects are sent iff transaction commits
model OutboxMessage {
  id            String   @id @default(cuid())
  event_type    String   // "BOOKING_CREATED", "PAYMENT_CONFIRMED"
  aggregate_type String  // "Booking", "Payslip"
  aggregate_id  String
  payload       Json
  
  processed     Boolean  @default(false)
  processed_at  DateTime?
  attempts      Int      @default(0)
  last_error    String?
  
  business_id   String
  created_at    DateTime @default(now())
  
  @@index([processed, created_at])
  @@index([business_id])
}

// Audit Trail: records who changed what and when
model AuditLog {
  id           String   @id @default(cuid())
  entity_type  String   // "Booking", "Payslip"
  entity_id    String
  action       String   // "CREATED", "STATUS_CHANGED"
  actor_id     String?  // User ID (nullable for system actions)
  actor_type   String   @default("USER") // "USER", "SYSTEM", "WEBHOOK"
  changes      Json?    // { before: {...}, after: {...} }
  
  business_id  String
  created_at   DateTime @default(now())
  
  @@index([entity_type, entity_id])
  @@index([business_id, created_at])
}
